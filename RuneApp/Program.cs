using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Configuration;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using Newtonsoft.Json;
using RuneOptim;
using RuneOptim.BuildProcessing;
using RuneOptim.Management;
using RuneOptim.swar;

namespace RuneApp {
    public enum LoadSaveResult {
        Failure = -2,
        FileNotFound = -1,
        EmptyFile = 0,
        Success = 1,
    }

    public static partial class Program {
        private static readonly log4net.ILog log = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);

        private static LineLogger lineLog = null;
        public static LineLogger LineLog {
            [DebuggerStepThrough] get {
                if (lineLog == null) {
                    var prof = Environment.GetEnvironmentVariable("DIAGHUB_SESSION_ID");
                    var prof2 = Environment.GetEnvironmentVariable("COR_ENABLE_PROFILING");
                    lineLog = new LineLogger((string.IsNullOrWhiteSpace(prof) && string.IsNullOrWhiteSpace(prof2)) ? log : null);

                }
                return lineLog;
            }
            set
            {
                lineLog = value;
            }
        }

        public static readonly Configuration config = ConfigurationManager.OpenExeConfiguration(Application.ExecutablePath);

        private static Save data;

        public static Save Data {
            get => data;
            set {
                foreach (var b in builds) {
                    if (!value.Monsters.Contains(b.Mon)) {
                        var mm = value.GetMonster(b.MonId);
                        if (mm != null) {
                            b.Mon = mm;
                        }
                        else {
                            // todo: failed to find referenced monster in new save.
                        }

                    }
                }

                data = value;
            }
        }

        public static event EventHandler<bool> OnRuneUpdate;
        public static event EventHandler<bool> OnMonsterUpdate;

        public static Goals goals;

        public static Properties.Settings Settings {
            get {
                //var qwete = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.PerUserRoamingAndLocal).FilePath;
                //Console.WriteLine(qwete);
                //Properties.Settings.Default.Upgrade();
                return Properties.Settings.Default;
            }
        }

        public static bool WatchSave {
            get { return Settings.WatchSave; }
            set {
                // TODO: start/stop Directory watcher
                Settings.WatchSave = value;
                Settings.Save();
            }
        }

        public static bool HasActiveBuild
        {
            get { return currentBuild != null; }
        }

        private static bool DoesSettingExist(string settingName) {
            return Properties.Settings.Default.Properties.OfType<SettingsProperty>().Any(prop => prop.Name == settingName);
        }

        public static event EventHandler<PrintToEventArgs> BuildsPrintTo;
        public static event EventHandler<ProgToEventArgs> BuildsProgressTo;

        /// <summary>
        /// The list of build definitions
        /// </summary>
        public static readonly ObservableCollection<Build> builds = new ObservableCollection<Build>();

        /// <summary>
        /// The current list of loadouts generated by running builds.
        /// </summary>
        public static readonly ObservableCollection<Loadout> loads = new ObservableCollection<Loadout>();

        private static bool isRunning = false;
        private static Build currentBuild = null;
        public static Build CurrentBuild => currentBuild;
        private static Task runTask = null;
        public static Task RunTask => runTask;
        private static CancellationToken runToken;
        private static CancellationTokenSource runSource = null;

        public static readonly RuneSheet runeSheet = new RuneSheet();

        public static readonly InternalServer.Master master = new InternalServer.Master();
        public static bool goodRunes;
        public static bool goFast;
        public static bool fillRunes;

        static FileSystemWatcher saveFileWatcher = null;
        static System.Timers.Timer saveFileDebouncer = null;
        public static event EventHandler saveFileTouched;

        private static TaskCompletionSource<int> readyTcs = new TaskCompletionSource<int>();
        public static Task Ready => readyTcs.Task;

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        public static void Main(string[] args) {

            if (args.Contains("-?") || args.Contains("--help"))
            {
                LineLog.Info("RuneApp - Summoners War Rune Optimizer.");
                LineLog.Info("");
                LineLog.Info("TODO: fill out this");
                LineLog.Info("");
                LineLog.Info("Usage:");
                LineLog.Info("\t -? | --help: show this help.");
                LineLog.Info("\t -a # | --affinity #: set the processor affinity to the first N 'cores'.");
                LineLog.Info("\t -H: run the Program headless (currently disables some features).");
                LineLog.Info("\t -S: disable internal server.");
                LineLog.Info("\t -W: disable watching save.");
                readyTcs.SetCanceled();
                return;
            }


            LineLog.Info("Program start");
            try {
                if (Settings.UpgradeRequired) {
                    Settings.Upgrade();
                    Settings.UpgradeRequired = false;
                    Settings.Save();
                }
            }
            catch (Exception e) {
                LineLog.Error("Failure upgrading settings.", e);
            }

            builds.CollectionChanged += Builds_CollectionChanged;
            loads.CollectionChanged += Loads_CollectionChanged;
            BuildsPrintTo += Program_BuildsPrintTo;

            if (Program.Settings.InternalServer && !args.Contains("-H") && !args.Contains("-S")) {
                try {
                    master.Start();
                }
                catch {
                    Program.Settings.InternalServer = false;
                    Program.Settings.Save();
                }
            }

            if (Program.Settings.WatchSave && !args.Contains("-H") && !args.Contains("-W"))
                watchSave();

            RuneLog.logTo = new progWriter();


            if (args.Contains("-a") || args.Contains("--affinity")) {
                int p = Array.IndexOf(args, "-a");
                if (p == -1)
                    p = Array.IndexOf(args, "--affinity");
                p += 1;

                if (p < args.Length && int.TryParse(args[p], out int procs))
                {
                    long pMask = 0;
                    for( int i = 0; i < procs; i++)
                    {
                        pMask |= 1 << i;
                    }

                    Process Proc = Process.GetCurrentProcess();
                    long AffinityMask = (long)Proc.ProcessorAffinity;
                    AffinityMask &= pMask;
                    //AffinityMask &= 0x000F; // use only any of the first 4 available processors
                    Proc.ProcessorAffinity = (IntPtr)AffinityMask;
                }
            }

            // Detect if we are profiling in VisualStudio
            var prof = Environment.GetEnvironmentVariable("DIAGHUB_SESSION_ID");
            var prof2 = Environment.GetEnvironmentVariable("COR_ENABLE_PROFILING");

            Application.ThreadException += Application_ThreadException;
            AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;
            TaskScheduler.UnobservedTaskException += TaskScheduler_UnobservedTaskException;

            if (!string.IsNullOrWhiteSpace(prof) || !string.IsNullOrWhiteSpace(prof2)) {
                RuneLog.logTo = null;
                //lineLog = null;
            }

            // TODO: find a better place to put this
            LoadGoals();

            if (!args.Contains("-H")) {
                Application.EnableVisualStyles();
                Application.SetCompatibleTextRenderingDefault(false);
                var main = new Main();
                main.Ready.ContinueWith(t => readyTcs.TrySetResult(1));
                Application.Run(main);
            }
            else {
                readyTcs.TrySetResult(-1);
            }
        }

        private static void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e) {
            MessageBox.Show(e.Exception.GetType() + ": " + e.Exception.Message + Environment.NewLine + e.Exception.StackTrace, "Task Error");
        }

        private static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e) {
            if (e.ExceptionObject is Exception exception)
                MessageBox.Show(exception.GetType() + ": " + exception.Message + Environment.NewLine + exception.StackTrace, "Domain Error");
            else
                MessageBox.Show(e.ExceptionObject?.ToString(), "Error");
        }

        private static void Application_ThreadException(object sender, ThreadExceptionEventArgs e) {
            MessageBox.Show(e.Exception.GetType() + ": " + e.Exception.Message + Environment.NewLine + e.Exception.StackTrace, "Thread Error");
        }

        static string lastPrint = null;
        private static void Program_BuildsPrintTo(object sender, PrintToEventArgs e) {
            if (e.Message != lastPrint) {
                lastPrint = e.Message;
                LineLog.Info(e.Message, e.Line, e.Caller, e.File);
            }
        }

        public static void ReadConfig() {
            if (config != null) {
                // it's stored as string, what is fasted yescompare?
                // this?
                /*
                if (config.AppSettings.Settings.AllKeys.Contains("nostats"))
                {
                    bool tstats;
                    if (bool.TryParse(config.AppSettings.Settings["nostats"].Value, out tstats))
                        makeStats = !tstats;
                }*/
            }
        }

        public static void Close() {
            // todo: not do this if headless?
            // is this the nicest way?
            Application.Exit();
        }

        private static void Loads_CollectionChanged(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e) {
            switch (e.Action) {
                case System.Collections.Specialized.NotifyCollectionChangedAction.Add:
                case System.Collections.Specialized.NotifyCollectionChangedAction.Reset:
                    break;
                case System.Collections.Specialized.NotifyCollectionChangedAction.Remove:
                    foreach (var l in e.OldItems.OfType<Loadout>()) {
                        l.Unlock();
                    }
                    break;
                case System.Collections.Specialized.NotifyCollectionChangedAction.Replace:
                case System.Collections.Specialized.NotifyCollectionChangedAction.Move:
                default:
                    throw new NotImplementedException();
            }
        }

        private static void Builds_CollectionChanged(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e) {
            switch (e.Action) {
                case System.Collections.Specialized.NotifyCollectionChangedAction.Add:
                    foreach (var b in e.NewItems.OfType<Build>()) {
                        if (Program.Data != null) {
                            // for each build, find the build in the buildlist with the same mon name?
                            //var bnum = buildList.Items.OfType<ListViewItem>().Select(it => it.Tag as Build).Where(d => d.MonName == b.MonName).Count();
                            // if there is a build with this monname, maybe I have 2 mons with that name?!
                            if (!System.Diagnostics.Debugger.IsAttached)
                                Program.LineLog.Debug("finding " + b.MonId);
                            var mon = Program.Data.GetMonster(b.MonId);
                            if (mon != null) {
                                b.Mon = mon;
                            }
                            else {
                                var bnum = builds.Count(bu => bu.MonName == b.MonName);
                                b.Mon = Program.Data.GetMonster(b.MonName, bnum + 1);
                            }
                            b.Shrines = Program.Data.shrines;
                        }
                        else {
                            b.Mon = new Monster();
                            b.Mon.FullName = b.MonName;
                        }
                    }
                    break;
                case System.Collections.Specialized.NotifyCollectionChangedAction.Remove:
                    break;
                case System.Collections.Specialized.NotifyCollectionChangedAction.Replace:
                case System.Collections.Specialized.NotifyCollectionChangedAction.Move:
                case System.Collections.Specialized.NotifyCollectionChangedAction.Reset:
                default:
                    throw new NotImplementedException();
            }
        }

        /// <summary>
        /// Checks the Working directory for a supported save file
        /// </summary>
        public static LoadSaveResult FindSave() {
            if (!string.IsNullOrWhiteSpace(Settings.SaveLocation) && File.Exists(Settings.SaveLocation))
                return LoadSave(Program.Settings.SaveLocation);

            if (File.Exists("save.json"))
                return LoadSave("save.json");

            // check the first 3 lines of JSON files for the HubUserLogin command
            var files = Directory.GetFiles(Environment.CurrentDirectory, "*.json")
                .Where(f => File.ReadLines(f).Take(3).Any(l => l.Contains("HubUserLogin")));

            if (files.Any() && files.HasCount(1)) 
                return LoadSave(files.First());

            return LoadSaveResult.FileNotFound;
        }

        public static LoadSaveResult LoadSave(string filename) {
            if (string.IsNullOrWhiteSpace(filename)) {
                LineLog.Error("Filename for save is null");
                return LoadSaveResult.FileNotFound;
            }
            if (!File.Exists(filename)) {
                LineLog.Error($"File {filename} doesn't exist");
                return LoadSaveResult.FileNotFound;
            }
            LineLog.Info("Loading " + filename + " as save.");
            string text = File.ReadAllText(filename);
            Program.Data = LoadSaveData(text, Program.loads);
            return LoadSaveResult.Success;
        }

        /// <summary>
        /// Takes in a JSON blob as the save
        /// </summary>
        /// <param name="text"></param>
        public static Save LoadSaveData(string text, IEnumerable<Loadout> matchLoads) {

#if !DEBUG
            try
#endif

            var dat = JsonConvert.DeserializeObject<Save>(text);

            // TODO: temp fix
            // this probably is somewhat of a leak, as the loadouts will have references to runes no-longer in the save (because the list was recreated in-place).
            foreach (var l in matchLoads) {
                for (int i = 0; i < 6; i++) {
                    if (l.Runes[i] == null)
                        continue;
                    var rr = dat.Runes.FirstOrDefault(r => r.Id == l.Runes[i].Id);
                    if (rr != null) {
                        l.Runes[i] = rr;
                    }
                    else {
                        l.Runes[i].AssignedId = 0;
                        l.Runes[i].AssignedName = "RUNE MISSING";
                    }
                }
                l.Lock();
            }

            //var bakemons = data.Monsters.Where(mo => !data.Monsters.Any(o => o.monsterTypeId == mo.monsterTypeId && o.Grade > 4));

            if (dat.isModified) {
                Console.WriteLine("Loaded data has been touched, untouching...");
                dat.isModified = false;
            }

            if (File.Exists("shrine_overwrite.json")) {
                dat.shrines.SetTo(JsonConvert.DeserializeObject<Stats>(File.ReadAllText("shrine_overwrite.json")));
                foreach (var m in dat.Monsters)
                    m.Current.Shrines = dat.shrines;
            }

#if !DEBUG
            catch (Exception e) {
                File.WriteAllText("error_save.txt", e.ToString());
                throw new Exception("Error occurred loading Save JSON.\r\n" + e.GetType() + "\r\nInformation is saved to error_save.txt");
            }
#endif
            return dat;
        }

        private static void watchSave() {
            if (saveFileWatcher == null) {
                saveFileWatcher = new FileSystemWatcher();
                saveFileWatcher.Changed += SaveFileWatcher_Changed;
            }
            saveFileWatcher.Path = Path.GetDirectoryName(Program.Settings.SaveLocation);
            saveFileWatcher.Filter = Path.GetFileName(Program.Settings.SaveLocation);
            saveFileWatcher.NotifyFilter = NotifyFilters.LastWrite;

        }

        private static void SaveFileWatcher_Changed(object sender, FileSystemEventArgs e) {
            if (saveFileDebouncer == null) {
                saveFileDebouncer = new System.Timers.Timer();
                saveFileDebouncer.Elapsed += SaveFileDebouncer_Elapsed;
                saveFileDebouncer.AutoReset = false;
            }
            saveFileDebouncer.Interval = 500;
            saveFileDebouncer.Stop();
            saveFileDebouncer.Start();
        }

        private static void SaveFileDebouncer_Elapsed(object sender, System.Timers.ElapsedEventArgs e) {
            if (saveFileTouched != null && saveFileTouched.GetInvocationList().Length > 0) {
                saveFileTouched.Invoke(Program.Settings.SaveLocation, new EventArgs());
            }
            else {
                LoadSave(Program.Settings.SaveLocation);
            }
        }

        static Dictionary<string, int[]> monPortraitMap = null;

        static byte[] zipData = null;
        static readonly object fslock = new object();

        public static string GetMonIconName(int monsterTypeId) {
            if (monPortraitMap == null)
                monPortraitMap = JsonConvert.DeserializeObject<Dictionary<string, int[]>>(File.ReadAllText("data\\unitmap.json"));

            var baseId = monsterTypeId / 100;

            int a, b, c;

            if (monPortraitMap.ContainsKey(monsterTypeId.ToString())) {
                var idl = monPortraitMap[monsterTypeId.ToString()];
                a = idl[0];
                c = idl[1];
                b = idl[2];
            }
            else if (!monPortraitMap.ContainsKey(baseId.ToString())) {
                return null;
            }
            else {
                var woke = (monsterTypeId / 10) % 10;
                if (!monPortraitMap.ContainsKey(baseId.ToString()))
                    return null;
                var idl = monPortraitMap[baseId.ToString()];
                if (woke * 2 + 1 > idl.Length)
                    return null;
                a = idl[woke * 2];
                b = idl[woke * 2 + 1];
                c = monsterTypeId % 10 - 1;
            }
            return $"unit_icon_{a:D4}_{c}_{b}";
        }

        public static Image GetMonPortrait(int monsterTypeId) {
            var e = GetMonIconName(monsterTypeId);
            if (string.IsNullOrWhiteSpace(e))
                return RuneApp.InternalServer.InternalServer.mon_spot;

            return Image.FromFile("data/unit/" + e + ".png");
        }


    }
}

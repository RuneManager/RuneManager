using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Configuration;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using Newtonsoft.Json;
using RuneOptim;
using RuneOptim.BuildProcessing;
using RuneOptim.Management;
using RuneOptim.swar;

namespace RuneApp {
	public enum LoadSaveResult {
		Failure = -2,
		FileNotFound = -1,
		EmptyFile = 0,
		Success = 1,
	}

	public static class Program {
		[Obsolete("try using the lineLog")]
		public static readonly log4net.ILog log = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);

		private static LineLogger lineLog = null;
		public static LineLogger LineLog {
			[DebuggerStepThrough] get {
				if (lineLog == null) {
					var prof = Environment.GetEnvironmentVariable("DIAGHUB_SESSION_ID");
					var prof2 = Environment.GetEnvironmentVariable("COR_ENABLE_PROFILING");
#pragma warning disable CS0618 // Type or member is obsolete
					lineLog = new LineLogger((string.IsNullOrWhiteSpace(prof) && string.IsNullOrWhiteSpace(prof2)) ? log : null);
#pragma warning restore CS0618 // Type or member is obsolete

				}
				return lineLog;
			}
		}

		public static readonly Configuration config = ConfigurationManager.OpenExeConfiguration(Application.ExecutablePath);

		public static Save data;

		public static event EventHandler<bool> OnRuneUpdate;
		public static event EventHandler<bool> OnMonsterUpdate;

		public static Goals goals;

		public static Properties.Settings Settings {
			get {
				//var qwete = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.PerUserRoamingAndLocal).FilePath;
				//Console.WriteLine(qwete);
				//Properties.Settings.Default.Upgrade();
				return Properties.Settings.Default;
			}
		}

		public static bool WatchSave {
			get { return Settings.WatchSave; }
			set {
				// TODO: start/stop Directory watcher
				Settings.WatchSave = value;
				Settings.Save();
			}
		}

		private static bool DoesSettingExist(string settingName) {
			return Properties.Settings.Default.Properties.OfType<SettingsProperty>().Any(prop => prop.Name == settingName);
		}

		public static event EventHandler<PrintToEventArgs> BuildsPrintTo;
		public static event EventHandler<ProgToEventArgs> BuildsProgressTo;

		/// <summary>
		/// The list of build definitions
		/// </summary>
		public static readonly ObservableCollection<Build> builds = new ObservableCollection<Build>();

		/// <summary>
		/// The current list of loadouts generated by running builds.
		/// </summary>
		public static readonly ObservableCollection<Loadout> loads = new ObservableCollection<Loadout>();

		private static bool isRunning = false;
		private static Build currentBuild = null;
		public static Build CurrentBuild => currentBuild;
		private static Task runTask = null;
		private static CancellationToken runToken;
		private static CancellationTokenSource runSource = null;

		public static readonly RuneSheet runeSheet = new RuneSheet();

		public static readonly InternalServer.Master master = new InternalServer.Master();
		public static bool goodRunes;
		public static bool goFast;
		public static bool fillRunes;

		static FileSystemWatcher saveFileWatcher = null;
		static System.Timers.Timer saveFileDebouncer = null;
		public static event EventHandler saveFileTouched;

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() {
			ReadConfig();
			LineLog.Info("Program start");
			try {
				if (Settings.UpgradeRequired) {
					Settings.Upgrade();
					Settings.UpgradeRequired = false;
					Settings.Save();
				}
			}
			catch (Exception e) {
				LineLog.Error("Failure upgrading settings.", e);
			}

			builds.CollectionChanged += Builds_CollectionChanged;
			loads.CollectionChanged += Loads_CollectionChanged;
			BuildsPrintTo += Program_BuildsPrintTo;

			if (Program.Settings.InternalServer) {
				try {
					master.Start();
				}
				catch {
					Program.Settings.InternalServer = false;
					Program.Settings.Save();
				}
			}

			if (Program.Settings.WatchSave)
				watchSave();

			RuneLog.logTo = new progWriter();


			if (false && Environment.MachineName == "SAMS-COMP") {
				Process Proc = Process.GetCurrentProcess();
				long AffinityMask = (long)Proc.ProcessorAffinity;
				AffinityMask &= 0x000F; // use only any of the first 4 available processors
				Proc.ProcessorAffinity = (IntPtr)AffinityMask;

				//ProcessThread Thread = Proc.Threads[0];
				//AffinityMask = 1 << 5; // use only the second processor, despite availability
				//Thread.ProcessorAffinity = (IntPtr)AffinityMask;
			}

			var prof = Environment.GetEnvironmentVariable("DIAGHUB_SESSION_ID");

			var prof2 = Environment.GetEnvironmentVariable("COR_ENABLE_PROFILING");

			Application.ThreadException += Application_ThreadException;
			AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;
			TaskScheduler.UnobservedTaskException += TaskScheduler_UnobservedTaskException;


			//MessageBox.Show(prof + "|" + prof2, "");

			if (!string.IsNullOrWhiteSpace(prof) || !string.IsNullOrWhiteSpace(prof2)) {
				RuneLog.logTo = null;
				//lineLog = null;
			}

			// TODO: find a better place to put this
			LoadGoals();

			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new Main());
		}

		private static void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e) {
			MessageBox.Show(e.Exception.GetType() + ": " + e.Exception.Message + Environment.NewLine + e.Exception.StackTrace , "Task Error");
		}

		private static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e) {
			if (e.ExceptionObject is Exception exception)
				MessageBox.Show(exception.GetType() + ": " + exception.Message + Environment.NewLine + exception.StackTrace , "Domain Error");
			else
				MessageBox.Show(e.ExceptionObject?.ToString() , "Error");
		}

		private static void Application_ThreadException(object sender, ThreadExceptionEventArgs e) {
			MessageBox.Show(e.Exception.GetType() + ": " + e.Exception.Message + Environment.NewLine + e.Exception.StackTrace , "Thread Error");
		}

		static string lastPrint = null;
		private static void Program_BuildsPrintTo(object sender, PrintToEventArgs e) {
			if (e.Message != lastPrint) {
				lastPrint = e.Message;
				LineLog.Info(e.Message, e.Line, e.Caller, e.File);
			}
		}

		public static void ReadConfig() {
			if (config != null) {
				// it's stored as string, what is fasted yescompare?
				// this?
				/*
				if (config.AppSettings.Settings.AllKeys.Contains("nostats"))
				{
					bool tstats;
					if (bool.TryParse(config.AppSettings.Settings["nostats"].Value, out tstats))
						makeStats = !tstats;
				}*/
			}
		}

		private static void Loads_CollectionChanged(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e) {
			switch (e.Action) {
				case System.Collections.Specialized.NotifyCollectionChangedAction.Add:
				case System.Collections.Specialized.NotifyCollectionChangedAction.Reset:
					break;
				case System.Collections.Specialized.NotifyCollectionChangedAction.Remove:
					foreach (var l in e.OldItems.OfType<Loadout>()) {
						l.Unlock();
					}
					break;
				case System.Collections.Specialized.NotifyCollectionChangedAction.Replace:
				case System.Collections.Specialized.NotifyCollectionChangedAction.Move:
				default:
					throw new NotImplementedException();
			}
		}

		private static void Builds_CollectionChanged(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e) {
			switch (e.Action) {
				case System.Collections.Specialized.NotifyCollectionChangedAction.Add:
					foreach (var b in e.NewItems.OfType<Build>()) {
						if (Program.data != null) {
							// for each build, find the build in the buildlist with the same mon name?
							//var bnum = buildList.Items.OfType<ListViewItem>().Select(it => it.Tag as Build).Where(d => d.MonName == b.MonName).Count();
							// if there is a build with this monname, maybe I have 2 mons with that name?!
							if (!System.Diagnostics.Debugger.IsAttached)
								Program.LineLog.Debug("finding " + b.MonId);
							var mon = Program.data.GetMonster(b.MonId);
							if (mon != null) {
								b.Mon = mon;
							}
							else {
								var bnum = builds.Count(bu => bu.MonName == b.MonName);
								b.Mon = Program.data.GetMonster(b.MonName, bnum + 1);
							}
							b.Shrines = Program.data.shrines;
						}
						else {
							b.Mon = new Monster();
							b.Mon.FullName = b.MonName;
						}
					}
					break;
				case System.Collections.Specialized.NotifyCollectionChangedAction.Remove:
					break;
				case System.Collections.Specialized.NotifyCollectionChangedAction.Replace:
				case System.Collections.Specialized.NotifyCollectionChangedAction.Move:
				case System.Collections.Specialized.NotifyCollectionChangedAction.Reset:
				default:
					throw new NotImplementedException();
			}
		}

		/// <summary>
		/// Checks the Working directory for a supported save file
		/// </summary>
		public static LoadSaveResult FindSave() {
			string[] files = Directory.GetFiles(Environment.CurrentDirectory, "*.json");
			if (!string.IsNullOrWhiteSpace(Settings.SaveLocation) && File.Exists(Settings.SaveLocation)) {
				return LoadSave(Program.Settings.SaveLocation);
			}
			else if (files.Any()) {
				if (!files.HasCount(1))
					return LoadSaveResult.FileNotFound;
				return LoadSave(files.First());
			}
			else if (File.Exists("save.json")) {
				return LoadSave("save.json");
			}
			return LoadSaveResult.FileNotFound;
		}

		public static LoadSaveResult LoadSave(string filename) {
			if (string.IsNullOrWhiteSpace(filename)) {
				LineLog.Error("Filename for save is null");
				return LoadSaveResult.FileNotFound;
			}
			if (!File.Exists(filename)) {
				LineLog.Error($"File {filename} doesn't exist");
				return LoadSaveResult.FileNotFound;
			}
			LineLog.Info("Loading " + filename + " as save.");
			string text = File.ReadAllText(filename);

#if !DEBUG
			try
#endif
			{
				Program.data = JsonConvert.DeserializeObject<Save>(text);

				// TODO: temp fix
				// this probably is somewhat of a leak, as the loadouts will have references to runes no-longer in the save (because the list was recreated in-place).
				foreach (var l in Program.loads) {
					foreach (var rid in l.RuneIDs) {
						var rr = Program.data.Runes.FirstOrDefault(r => r.Id == rid);
						if (rr != null)
							rr.Locked = true;
					}
				}

				//var bakemons = data.Monsters.Where(mo => !data.Monsters.Any(o => o.monsterTypeId == mo.monsterTypeId && o.Grade > 4));

				if (data.isModified) {
					Console.WriteLine("Loaded data has been touched, untouching...");
					data.isModified = false;
				}

				if (File.Exists("shrine_overwrite.json")) {
					Program.data.shrines.SetTo(JsonConvert.DeserializeObject<Stats>(File.ReadAllText("shrine_overwrite.json")));
					foreach (var m in data.Monsters)
						m.Current.Shrines = data.shrines;
				}
			}
#if !DEBUG
			catch (Exception e) {
				File.WriteAllText("error_save.txt", e.ToString());
				throw new Exception("Error occurred loading Save JSON.\r\n" + e.GetType() + "\r\nInformation is saved to error_save.txt");
			}
#endif
			return LoadSaveResult.Success;
		}

		private static void watchSave() {
			if (saveFileWatcher == null) {
				saveFileWatcher = new FileSystemWatcher();
				saveFileWatcher.Changed += SaveFileWatcher_Changed;
			}
			saveFileWatcher.Path = Path.GetDirectoryName(Program.Settings.SaveLocation);
			saveFileWatcher.Filter = Path.GetFileName(Program.Settings.SaveLocation);
			saveFileWatcher.NotifyFilter = NotifyFilters.LastWrite;

		}

		private static void SaveFileWatcher_Changed(object sender, FileSystemEventArgs e) {
			if (saveFileDebouncer == null) {
				saveFileDebouncer = new System.Timers.Timer();
				saveFileDebouncer.Elapsed += SaveFileDebouncer_Elapsed;
				saveFileDebouncer.AutoReset = false;
			}
			saveFileDebouncer.Interval = 500;
			saveFileDebouncer.Stop();
			saveFileDebouncer.Start();
		}

		private static void SaveFileDebouncer_Elapsed(object sender, System.Timers.ElapsedEventArgs e) {
			if (saveFileTouched != null && saveFileTouched.GetInvocationList().Length > 0) {
				saveFileTouched.Invoke(Program.Settings.SaveLocation, new EventArgs());
			}
			else {
				LoadSave(Program.Settings.SaveLocation);
			}
		}

		public static LoadSaveResult LoadBuilds(string filename = "builds.json") {
			if (!File.Exists(filename)) {
				LineLog.Error($"{filename} wasn't found.");
				return LoadSaveResult.FileNotFound;
			}
			LineLog.Debug($"Loading {filename} as builds.");

#if !DEBUG
			try {
#endif
				var bstr = File.ReadAllText(filename);

				// upgrade:
				bstr = bstr.Replace("\"b_hp\"", "\"hp\"");
				bstr = bstr.Replace("\"b_atk\"", "\"atk\"");
				bstr = bstr.Replace("\"b_def\"", "\"def\"");
				bstr = bstr.Replace("\"b_spd\"", "\"spd\"");
				bstr = bstr.Replace("\"b_crate\"", "\"critical_rate\"");
				bstr = bstr.Replace("\"b_cdmg\"", "\"critical_damage\"");
				bstr = bstr.Replace("\"b_acc\"", "\"accuracy\"");
				bstr = bstr.Replace("\"b_res\"", "\"res\"");

				var bs = JsonConvert.DeserializeObject<List<Build>>(bstr);
				foreach (var b in bs.OrderBy(b => b.Priority)) {
					builds.Add(b);
				}
				foreach (var b in builds.Where(b => b.Type == BuildType.Link)) {
					b.LinkBuild = Program.builds.FirstOrDefault(bu => bu.ID == b.LinkId);
				}
#if !DEBUG
			}
			catch (Exception e) {
				File.WriteAllText("error_build.txt", e.ToString());
				throw new InvalidOperationException("Error occurred loading Build JSON.\r\n" + e.GetType() + "\r\nInformation is saved to error_build.txt");
			}
#endif

			if (Program.builds.Count > 0 && (Program.data?.Monsters == null)) {
				// backup, just in case
				string destFile = Path.Combine("", string.Format("{0}.backup{1}", "builds", ".json"));
				int num = 2;
				while (File.Exists(destFile)) {
					destFile = Path.Combine("", string.Format("{0}.backup{1}{2}", "builds", num, ".json"));
					num++;
				}

				File.Copy("builds.json", destFile);
				return LoadSaveResult.Failure;
			}

			SanitizeBuilds();

			return LoadSaveResult.Success;
		}

		public static void SanitizeBuilds() {
			LineLog.Debug("processing builds");
			int current_pri = 1;
			foreach (Build b in Program.builds.OrderBy(bu => bu.Priority)) {
				int id = b.ID;
				if (b.ID == 0 || Program.builds.Where(bu => bu != b).Select(bu => bu.ID).Any(bid => bid == b.ID)) {
					//id = buildList.Items.Count + 1;
					id = 1;
					while (Program.builds.Any(bu => bu.ID == id))
						id++;

					foreach (var lb in Program.builds.Where(bu => bu.LinkId == b.ID)) {
						lb.LinkId = id;
					}

					b.ID = id;
				}
				if (b.Type == BuildType.Lock)
					b.Priority = 0;
				else
					b.Priority = current_pri++;

				// make sure bad things are removed
				foreach (var ftab in b.RuneFilters) {
					foreach (var filter in ftab.Value) {
						if (filter.Key == "SPD")
							filter.Value.Percent = null;
						if (filter.Key == "ACC" || filter.Key == "RES" || filter.Key == "CR" || filter.Key == "CD")
							filter.Value.Flat = null;
					}
				}

				// upgrade builds, hopefully
				while (b.VERSIONNUM < Create.VERSIONNUM) {
					switch (b.VERSIONNUM) {
						case 0: // unversioned to 1
							b.Threshold = b.Maximum;
							b.Maximum = new Stats();
							break;
						case 1:
							foreach (var tabN in b.RuneScoring.Keys.ToArray()) {
								var tab = b.RuneScoring[tabN];
								if (tab.Type == FilterType.SumN) {
									tab.Count = (int?)(tab.Value);
									tab.Value = null;
									b.RuneScoring[tabN] = tab;
								}
							}
							break;
					}
					b.VERSIONNUM++;
				}
			}
		}

		public static LoadSaveResult SaveBuilds(string filename = "builds.json") {
			LineLog.Debug($"Saving builds to {filename}");
			// TODO: fix this mess
			foreach (Build bb in builds) {
				if (bb.Mon != null && bb.Mon.FullName != "Missingno") {
					if (!bb.DownloadAwake || (Program.data.GetMonster(bb.Mon.FullName) != null && Program.data.GetMonster(bb.Mon.FullName).FullName != "Missingno")) {
						bb.MonName = bb.Mon.FullName;
						bb.MonId = bb.Mon.Id;
					}
					else {
						if (Program.data.GetMonster(bb.Mon.Id).FullName != "Missingno") {
							bb.MonId = bb.Mon.Id;
							bb.MonName = Program.data.GetMonster(bb.Mon.Id).FullName;
						}
					}
				}
			}

			// only write if there are builds, may save some files
			if (Program.builds.Count > 0) {
				try {
					// keep a single recent backup
					if (File.Exists(filename))
						File.Copy(filename, filename + ".backup", true);
					var str = JsonConvert.SerializeObject(Program.builds, Formatting.Indented);
					File.WriteAllText(filename, str);
					return LoadSaveResult.Success;
				}
				catch (Exception e) {
					LineLog.Error($"Error while saving builds {e.GetType()}", e);
					throw;
					//MessageBox.Show(e.ToString());
				}
			}
			return LoadSaveResult.Failure;
		}

		public static LoadSaveResult SaveLoadouts(string filename = "loads.json") {
			LineLog.Debug($"Saving loads to {filename}");

			if (loads.Count > 0) {
				try {
					// keep a single recent backup
					if (File.Exists(filename))
						File.Copy(filename, filename + ".backup", true);
					var str = JsonConvert.SerializeObject(loads, Formatting.Indented);
					File.WriteAllText(filename, str);
					return LoadSaveResult.Success;
				}
				catch (Exception e) {
					LineLog.Error($"Error while saving loads {e.GetType()}", e);
					throw;
				}
			}
			return LoadSaveResult.EmptyFile;
		}

		public static LoadSaveResult LoadLoadouts(string filename = "loads.json") {
			try {
				string text = File.ReadAllText(filename);
				var lloads = JsonConvert.DeserializeObject<Loadout[]>(text);
				loads.Clear();

				foreach (var load in lloads) {
					if (load.RuneIDs != null) {
						for (int i = 0; i < 6; i++) {
							var ids = load.RuneIDs[i];
							load.Runes[i] = Program.data.Runes.FirstOrDefault(r => r.Id == ids);
							if (load.Runes[i] != null) {
								load.Runes[i].Locked = true;
								if (load.manageStats != null)
									foreach (var ms in load.manageStats[i])
										load.Runes[i].manageStats.AddOrUpdate(ms.Key, ms.Value, (s, d) => ms.Value);
							}
						}
					}
					load.Shrines = data.shrines;
					loads.Add(load);
				}
				return LoadSaveResult.Success;
			}
			catch (Exception e) {
				LineLog.Error($"Error while loading loads {e.GetType()}", e);
				//MessageBox.Show("Error occurred loading Save JSON.\r\n" + e.GetType() + "\r\nInformation is saved to error_save.txt");
				File.WriteAllText("error_loads.txt", e.ToString());
				throw;
			}
		}

		internal static void ClearLoadouts() {
			foreach (Loadout l in loads) {
				l.Unlock();
			}
			loads.Clear();
		}

		public static LoadSaveResult SaveGoals(string filename = "goals.json") {
			LineLog.Debug($"Saving loads to {filename}");

			try {
				// keep a single recent backup
				var str = JsonConvert.SerializeObject(goals, Formatting.Indented);
				File.WriteAllText(filename, str);
				return LoadSaveResult.Success;
			}
			catch (Exception e) {
				LineLog.Error($"Error while saving loads {e.GetType()}", e);
				throw;
			}
		}

		public static LoadSaveResult LoadGoals(string filename = "goals.json") {
			try {
				LineLog.Debug("Loading goals");
				if (File.Exists(filename)) {
					string text = File.ReadAllText(filename);
					goals = JsonConvert.DeserializeObject<Goals>(text);
				}
				else {
					goals = new Goals();
				}
				return LoadSaveResult.Success;
			}
			catch (Exception e) {
				LineLog.Error($"Error while loading goals {e.GetType()}", e);
				File.WriteAllText("error_goals.txt", e.ToString());
				throw;
			}
		}

		public static void BuildPriority(Build build, int deltaPriority) {
			build.Priority += deltaPriority;
			var bpri = builds.OrderBy(b => b.Priority).ThenBy(b => b == build ? deltaPriority : 0).ToList();
			int i = 1;
			foreach (var b in bpri) {
				if (b.Type == BuildType.Lock) {
					b.Priority = 0;
				}
				else
					b.Priority = i++;
			}
		}

		public static void RunTest(Build build, Action<Build, BuildResult> onFinish = null) {
			if (build.IsRunning)
				throw new InvalidOperationException("This build is already running");

			Task.Factory.StartNew(() => {
				// Allow the window to draw before destroying the CPU
				Thread.Sleep(100);

				// Disregard locked, but honor equippedness checking
				build.RunesUseEquipped = Program.Settings.UseEquipped;
				build.RunesUseLocked = Program.Settings.LockTest;
				build.BuildGenerate = Program.Settings.TestGen;
				build.BuildTake = Program.Settings.TestShow;
				build.BuildTimeout = Program.Settings.TestTime;
				build.Shrines = Program.data.shrines;
				build.BuildDumpBads = false;
				build.BuildSaveStats = false;
				build.BuildGoodRunes = false;
				build.RunesOnlyFillEmpty = Program.fillRunes;
				build.RunesDropHalfSetStat = Program.goFast;
				build.IgnoreLess5 = Program.Settings.IgnoreLess5;

				build.GenRunes(Program.data);
				var result = build.GenBuilds();

				onFinish?.Invoke(build, result);
			});
		}

		public static void StopBuild() {
			runSource?.Cancel();
			if (currentBuild.runner != null) {
				currentBuild.runner.Cancel();
			}
		}

		public static void RunBuild(Build build, bool saveStats = false) {
			if (Program.data == null)
				return;


			if (currentBuild != null) {
				if (runTask != null && runTask.Status != TaskStatus.Running)
					throw new Exception("Already running builds!");
				else {
					runSource.Cancel();
					if (currentBuild.runner != null) {
						currentBuild.runner.Cancel();
					}
					return;
				}
			}

			runSource = new CancellationTokenSource();
			runToken = runSource.Token;
			runTask = Task.Factory.StartNew(() => {
				runBuild(build, saveStats);
			}, runToken);
		}

		private static void runBuild(Build build, bool saveStats = false) {
			runBuild(build, Program.data, new BuildSettings() {
				BuildSaveStats = saveStats,
				RunesUseEquipped = Program.Settings.UseEquipped,
				Shrines = Program.data.shrines,
				RunesOnlyFillEmpty = Program.fillRunes,
				RunesDropHalfSetStat = Program.goFast,
				IgnoreLess5 = Program.Settings.IgnoreLess5,
				BuildDumpBads = true,
			});
		}

		// TODO: pull more of the App-dependant stuff out
		private static void runBuild(Build build, Save data, BuildSettings bSettings) {
				try {
				if (build == null) {
					LineLog.Info("Build is null");
					return;
				}
				// TODO: show this somewhere
				if (currentBuild != null)
					throw new InvalidOperationException("Already running a build");
				if (build.IsRunning)
					throw new InvalidOperationException("This build is already running");
				currentBuild = build;

				LineLog.Info("Starting watch " + build.ID + " " + build.MonName);

				Stopwatch buildTime = Stopwatch.StartNew();
				
				// TODO: get builds to use the settings directly
				build.RunesUseEquipped = bSettings.RunesUseEquipped;
				build.RunesUseLocked = bSettings.RunesUseLocked;
				build.BuildGenerate = bSettings.BuildGenerate;
				build.BuildTake = bSettings.BuildTake;
				build.BuildTimeout = bSettings.BuildTimeout;
				build.Shrines = bSettings.Shrines;
				build.BuildDumpBads = bSettings.BuildDumpBads;
				build.BuildSaveStats = bSettings.BuildSaveStats;
				build.BuildGoodRunes = bSettings.BuildGoodRunes;
				build.RunesOnlyFillEmpty = bSettings.RunesOnlyFillEmpty;
				build.RunesDropHalfSetStat = bSettings.RunesDropHalfSetStat;
				build.IgnoreLess5 = bSettings.IgnoreLess5;


				BuildsPrintTo?.Invoke(null, PrintToEventArgs.GetEvent(build, "Runes..."));
				if (build.Type == BuildType.Link) {
					build.CopyFrom(build.LinkBuild);
				}
				
				// unlock current build (if present)
				if (build.Mon?.Current != null) 
					build.Mon?.Current.Unlock();
				
				build.GenRunes(data);

				#region Check enough runes
				string nR = "";
				for (int i = 0; i < build.runes.Length; i++) {
					if (build.runes[i] != null && build.runes[i].Length == 0)
						nR += (i + 1) + " ";
				}

				if (nR != "") {
					BuildsPrintTo?.Invoke(null, PrintToEventArgs.GetEvent(build, ":( " + nR + "Runes"));
					return;
				}
				#endregion

				build.BuildPrintTo += BuildsPrintTo;
				build.BuildProgTo += BuildsProgressTo;

				EventHandler<ProgToEventArgs> qw = (bq, s) => {
					if (runToken.IsCancellationRequested)
						build.Cancel();
				};
				build.BuildProgTo += qw;

				var result = build.GenBuilds();

				buildTime.Stop();
				build.Time = buildTime.ElapsedMilliseconds;
				LineLog.Info("Stopping watch " + build.ID + " " + build.MonName + " @ " + buildTime.ElapsedMilliseconds);

				if (build.Best != null) {
					BuildsPrintTo?.Invoke(null, PrintToEventArgs.GetEvent(build, "Best"));

					build.Best.Current.BuildID = build.ID;

					#region Get the rune diff
					build.Best.Current.Lock();
					build.Best.Current.RecountDiff(build.Mon.Id);
					#endregion

					//currentBuild = null;
					build.Best.Current.Time = build.Time;

					var dmon = Program.data.GetMonster(build.Best.Id);

					var dmonld = dmon.Current.Leader;
					var dmonsh = dmon.Current.Shrines;
					dmon.Current.Leader = build.Best.Current.Leader;
					dmon.Current.Shrines = build.Best.Current.Shrines;
					var dmonfl = dmon.Current.FakeLevel;
					var dmonps = dmon.Current.PredictSubs;
					dmon.Current.FakeLevel = build.Best.Current.FakeLevel;
					dmon.Current.PredictSubs = build.Best.Current.PredictSubs;
					var dmonbf = dmon.Current.Buffs;
					dmon.Current.Buffs = build.Best.Current.Buffs;

					var ds = build.CalcScore(dmon.GetStats());
					var cs = build.CalcScore(build.Best.Current.GetStats(build.Best));
					build.Best.Current.DeltaPoints = cs - ds;

					dmon.Current.Leader = dmonld;
					dmon.Current.Shrines = dmonsh;
					dmon.Current.FakeLevel = dmonfl;
					dmon.Current.PredictSubs = dmonps;
					dmon.Current.Buffs = dmonbf;

					loads.Add(build.Best.Current);

					// if we are on the hunt of good runes.
					if (goodRunes && bSettings.BuildSaveStats && build.Type != BuildType.Lock) {
						var theBest = build.Best;
						int count = 0;
						// we must progressively ban more runes from the build to find second-place runes.
						//GenDeep(b, 0, printTo, ref count);
						RunBanned(build, ++count, theBest.Current.Runes.Where(r => r.Slot % 2 != 0).Select(r => r.Id).ToArray());
						RunBanned(build, ++count, theBest.Current.Runes.Where(r => r.Slot % 2 == 0).Select(r => r.Id).ToArray());
						RunBanned(build, ++count, theBest.Current.Runes.Select(r => r.Id).ToArray());

						// after messing all that shit up
						build.Best = theBest;
					}

					#region Save Build stats

					/* TODO: put Excel on Program */
					if (bSettings.BuildSaveStats && build.Type != BuildType.Lock) {
						BuildsPrintTo?.Invoke(null, PrintToEventArgs.GetEvent(build, "Excel"));
						runeSheet.StatsExcelBuild(build, build.Mon, build.Best.Current, true);
					}

					BuildsPrintTo?.Invoke(null, PrintToEventArgs.GetEvent(build, "Clean"));
					// clean up for GC
					if (build.BuildUsage != null)
						build.BuildUsage.loads.Clear();
					if (build.RuneUsage != null) {
						build.RuneUsage.runesGood.Clear();
						build.RuneUsage.runesUsed.Clear();
					}
					build.RuneUsage = null;
					build.BuildUsage = null;
					/**/
					#endregion
				}

				build.BuildPrintTo -= BuildsPrintTo;
				build.BuildProgTo -= qw;
				build.BuildProgTo -= BuildsProgressTo;

				//if (plsDie)
				//    printTo?.Invoke("Canned");
				//else 
				if (build.Best != null)
					BuildsPrintTo?.Invoke(null, PrintToEventArgs.GetEvent(build, "Done"));
				else
					BuildsPrintTo?.Invoke(null, PrintToEventArgs.GetEvent(build, result + " :("));

				LineLog.Info("Cleaning up");
				//b.isRun = false;
				//currentBuild = null;
			}
			catch (Exception e) {
				LineLog.Error("Error during build " + build.ID + " " + e.Message + Environment.NewLine + e.StackTrace);
			}
			finally {
				currentBuild = null;
				LineLog.Info("Cleaned");
			}
		}

		private static void RunBanned(Build b, int c, params ulong[] doneIds) {
			LineLog.Info("Running ban");
			try {
				b.BanEmTemp(doneIds);

				b.RunesUseLocked = false;
				b.RunesUseEquipped = Program.Settings.UseEquipped;
				b.BuildSaveStats = true;
				b.RunesOnlyFillEmpty = Program.fillRunes;
				b.BuildGoodRunes = goodRunes;
				b.RunesDropHalfSetStat = Program.goFast;
				b.IgnoreLess5 = Program.Settings.IgnoreLess5;
				b.GenRunes(Program.data);

				b.BuildTimeout = 0;
				b.BuildTake = 0;
				b.BuildGenerate = 0;
				b.BuildDumpBads = true;
				var result = b.GenBuilds($"{c} ");
				b.BuildGoodRunes = false;
				LineLog.Info("ran ban with result: " + result);
			}
			catch (Exception ex) {
				LineLog.Error("Running ban failed ", ex);
			}
			finally {
				b.BanEmTemp(new ulong[] { });
				b.BuildSaveStats = false;
				b.GenRunes(Program.data);
				LineLog.Info("Ban finished");
			}
		}

		public static void RunBuilds(bool skipLoaded, int runTo = -1) {
			if (Program.data == null)
				return;

			if (isRunning) {
				if (runTask != null && runTask.Status != TaskStatus.Running)
					throw new Exception("Already running builds!");
				else {
					runSource.Cancel();
					return;
				}
			}
			isRunning = true;

			try {
				if (runTask != null && runTask.Status == TaskStatus.Running) {
					runSource.Cancel();
					//if (currentBuild != null)
					//   currentBuild.isRun = false;
					//plsDie = true;
					isRunning = false;
					return;
				}
				//plsDie = false;

				List<int> loady = new List<int>();

				if (!skipLoaded) {
					ClearLoadouts();
					foreach (var r in Program.data.Runes) {
						r.manageStats.AddOrUpdate("buildScoreIn", 0, (k, v) => 0);
						r.manageStats.AddOrUpdate("buildScoreTotal", 0, (k, v) => 0);
					}
				}

				List<Build> toRun = new List<Build>();
				foreach (var build in builds.OrderBy(b => b.Priority)) {
					if ((!skipLoaded || !loads.Any(l => l.BuildID == build.ID)) && (runTo == -1 || build.Priority <= runTo))
						toRun.Add(build);
				}

				/*
				bool collect = true;
				int newPri = 1;
				// collect the builds
				List<ListViewItem> list5 = new List<ListViewItem>();
				foreach (ListViewItem li in buildList.Items)
				{
					li.SubItems[0].Text = newPri.ToString();
					(li.Tag as Build).priority = newPri++;

					if (loady.Contains((li.Tag as Build).ID))
						continue;

					if ((li.Tag as Build).ID == runTo)
						collect = false;

					if (collect)
						list5.Add(li);

					li.SubItems[3].Text = "";
				}
				*/

				runSource = new CancellationTokenSource();
				runToken = runSource.Token;
				runTask = Task.Factory.StartNew(() => {
					if (Program.data.Runes != null && !skipLoaded) {
						foreach (Rune r in Program.data.Runes) {
							r.Swapped = false;
							r.ResetStats();
						}
					}

					foreach (Build bbb in toRun) {
						runBuild(bbb, Program.Settings.MakeStats);
						if (runToken.IsCancellationRequested || bbb.Best == null)
							break;
					}

					if (!runToken.IsCancellationRequested && Program.Settings.MakeStats) {
						if (!skipLoaded)
							Program.runeSheet.StatsExcelRunes(true);
						try {
							Program.runeSheet.StatsExcelSave(true);
						}
						catch (Exception ex) {
							Console.WriteLine(ex);
						}
					}
					isRunning = false;
				}, runSource.Token);
			}
			catch (Exception e) {
				MessageBox.Show(e.Message + Environment.NewLine + e.StackTrace, e.GetType().ToString());
			}
		}

		public static void SaveData() {
			// tag the save as a modified save
			Program.data.isModified = true;
			var l = Program.data.Runes.Where(r => r.Locked);
			foreach (var r in l)
				r.Locked = false;

			if (File.Exists(Program.Settings.SaveLocation)) {
				// backup, just in case
				string fname = Path.ChangeExtension(Program.Settings.SaveLocation, ".backup.json");
				int i = 2;
				while (File.Exists(fname))
					fname = Path.ChangeExtension(Program.Settings.SaveLocation, ".backup" + (i++) + ".json");
				File.Copy(Program.Settings.SaveLocation, fname);
			}

			File.WriteAllText(Program.Settings.SaveLocation, JsonConvert.SerializeObject(Program.data, Formatting.Indented));

			foreach (var r in l)
				r.Locked = true;
		}

		public static void AddMonster(Monster mon) {
			if (data.Monsters.Any(m => m.Id == mon.Id)) {
				UpdateMonster(mon);
				return;
			}

			if (mon.WizardId == data.WizardInfo.Id) {
				data.Monsters.Add(mon);
				data.isModified = true;
				OnMonsterUpdate?.Invoke(mon, false);
			}
		}

		public static void AddRune(Rune rune) {
			if (data.Runes.Any(r => r.Id == rune.Id)) {
				UpdateRune(rune);
				return;
			}

			if (rune.WizardId == data.WizardInfo.Id) {
				data.Runes.Add(rune);
				data.isModified = true;
				OnRuneUpdate?.Invoke(rune, false);
			}
		}

		public static void DeleteMonster(Monster mon) {
			var m = data.GetMonster(mon.Id);
			data.Monsters.Remove(m);

			data.isModified = true;
			OnMonsterUpdate?.Invoke(mon, true);
		}

		public static void DeleteRune(Rune rune) {
			var r = data.GetRune(rune.Id);
			data.Runes.Remove(r);

			data.isModified = true;
			OnRuneUpdate?.Invoke(rune, true);
		}

		public static void UpdateMonster(Monster mon) {
			var m = data.GetMonster(mon.Id);
			if (m == null) {
				AddMonster(mon);
				return;
			}

			// TODO: modify stats and trigger callbacks
			m.level = mon.level;
			m.Grade = mon.Grade;
			m.monsterTypeId = mon.monsterTypeId;

			foreach (var attr in Build.StatEnums) {
				m[attr] = mon[attr];
			}

			for (int i = 0; i < mon._SkillList.Count; i++) {
				m._SkillList[i].Level = mon._SkillList[i].Level;
			}
			m.damageFormula = null;
			m.RefreshStats();

			for (int i = 0; i < 6; i++) {
				// find the changes per slot
				var rl = mon.Runes.FirstOrDefault(r => r.Slot - 1 == i);
				if (rl != null) {
					var rune = data.GetRune(rl.Id);
					if (rune != null) {
						// if the new rune is assigned to someone else
						if (rune.AssignedId != m.Id && rune.AssignedId > 0) {
							var om = data.GetMonster(rune.AssignedId);
							var rm = om?.RemoveRune(rune.Slot);
							if (rm != null) {
								rm.Assigned = null;
								rm.AssignedId = 0;
								rm.AssignedName = "Unassigned";
							}
						}
						// unassign any runes that point to this slot (just to be safe)
						/*foreach (var r in data.Runes.Where(r => r.AssignedId == m.Id && r.Slot - 1 == i)) {
							r.Assigned = null;
							r.AssignedId = 0;
							r.AssignedName = "Unassigned";
						}*/
						// assign the new rune to the current monster
						rune.AssignedId = m.Id;
						rune.Assigned = m;
						rune.AssignedName = m.FullName;
						if (rune != m.Current.Runes[i]) {
							var rm = m.ApplyRune(rune);
							if (rm != null) {
								rm.Assigned = null;
								rm.AssignedId = 0;
								rm.AssignedName = "Unassigned";
							}
						}
					}
				}
				else {
					// pull a rune off, if that don't work find anyrune who was pointing at my slot
					var rm = m.RemoveRune(i + 1) ?? data.Runes.FirstOrDefault(r => r.AssignedId == m.Id && r.Slot - 1 == i);
					if (rm != null) {
						rm.Assigned = null;
						rm.AssignedId = 0;
						rm.AssignedName = "Unassigned";
					}
				}
			}

			data.isModified = true;
			OnMonsterUpdate?.Invoke(m, false);
		}

		public static void UpdateRune(Rune rune, bool keepLocked = true, Monster newAssigned = null) {
			var r = data.GetRune(rune.Id);
			if (r == null)
				return;
			// TODO: modify stats and trigger callbacks
			rune.CopyTo(r, keepLocked, newAssigned);

			//r.Assigned?.Current.AddRune(r);

			data.isModified = true;
			OnRuneUpdate?.Invoke(r, false);
		}

		static Dictionary<string, int[]> monPortraitMap = null;

		static byte[] zipData = null;
		static readonly object fslock = new object();

		public static string GetMonIconName(int monsterTypeId) {
			if (monPortraitMap == null)
				monPortraitMap = JsonConvert.DeserializeObject<Dictionary<string, int[]>>(File.ReadAllText("data\\unitmap.json"));

			var baseId = monsterTypeId / 100;

			int a, b, c;

			if (monPortraitMap.ContainsKey(monsterTypeId.ToString())) {
				var idl = monPortraitMap[monsterTypeId.ToString()];
				a = idl[0];
				c = idl[1];
				b = idl[2];
			}
			else if (!monPortraitMap.ContainsKey(baseId.ToString())) {
				return null;
			}
			else {
				var woke = (monsterTypeId / 10) % 10;
				if (!monPortraitMap.ContainsKey(baseId.ToString()))
					return null;
				var idl = monPortraitMap[baseId.ToString()];
				if (woke * 2 + 1 > idl.Length)
					return null;
				a = idl[woke * 2];
				b = idl[woke * 2 + 1];
				c = monsterTypeId % 10 - 1;
			}
			return $"unit_icon_{a:D4}_{c}_{b}";
		}

		public static Image GetMonPortrait(int monsterTypeId) {
			var e = GetMonIconName(monsterTypeId);
			if (string.IsNullOrWhiteSpace(e))
				return RuneApp.InternalServer.InternalServer.mon_spot;

			return Image.FromFile("data/unit/" + e + ".png");
		}


		#region Extension Methods
		public static bool IsConnected(this Socket socket) {
			try {
				return !(socket.Poll(1, SelectMode.SelectRead) && socket.Available == 0);
			}
			catch (SocketException) { return false; }
		}

		public static double StandardDeviation<T>(this IEnumerable<T> src, Func<T, double> selector) {
			double av = src.Where(p => Math.Abs(selector(p)) > 0.00000001).Average(selector);
			List<double> nls = new List<double>();
			foreach (var o in src.Where(p => Math.Abs(selector(p)) > 0.00000001)) {
				nls.Add((selector(o) - av) * (selector(o) - av));
			}
			double avs = nls.Average();
			return Math.Sqrt(avs);
		}

		public static T MakeControl<T>(this Control.ControlCollection ctrlC, Attr attr, string suff, int x, int y, int w = 40, int h = 20, string text = null)
			where T : Control, new() {
			return MakeControl<T>(ctrlC, attr.ToShortForm(), suff, x, y, w, h, text);
		}

		public static T MakeControl<T>(this Control.ControlCollection ctrlC, string name, string suff, int x, int y, int w = 40, int h = 20, string text = null)
			where T : Control, new() {
			T ctrl = new T()
			{
				Name = name + suff,
				Size = new Size(w, h),
				Location = new Point(x, y),
				Text = text
			};
			ctrlC.Add(ctrl);

			return ctrl;
		}

		//http://stackoverflow.com/a/77233
		public static void SetDoubleBuffered(this System.Windows.Forms.Control c) {
			//Taxes: Remote Desktop Connection and painting
			//http://blogs.msdn.com/oldnewthing/archive/2006/01/03/508694.aspx
			if (System.Windows.Forms.SystemInformation.TerminalServerSession)
				return;

			System.Reflection.PropertyInfo aProp =
				  typeof(System.Windows.Forms.Control).GetProperty(
						"DoubleBuffered",
						System.Reflection.BindingFlags.NonPublic |
						System.Reflection.BindingFlags.Instance);

			aProp.SetValue(c, true, null);
		}

		#endregion

	}
}
